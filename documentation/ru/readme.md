## Документация

Добро пожаловать в **Regenix framework** документацию.

#### Обзор

Regenix framework является классическим веб MVC фреймворком для PHP.
Основной фокус идет на быструю и продуктивную разработку, с использованием
REST архитектуры.

#### PHP Фреймворк легкий и мощный

Regenix является легким и в тоже время мощным фреймворком. Непростая история самого
языка PHP отразилась на всех mvc фреймворках, которые существуют на PHP. MVC
фреймворки часто страдают перегруженностью, сложной настройкой и установкой. Некоторые
фреймворки тянут за собой старый код не лучшего качества, некоторые не слишком
функциональны.

#### Простая MVC архитектура

Regenix предоставляет очень простую и понятную архитектуру MVC. Модели, представления и контроллеры.
Архитектура веб приложений из года в год совершенствуется и становится сложнее.
Фреймворки должны предоставлять прозрачную и простую систему для построения современных
веб-приложений. Это относится к простым веб приложениям, к ajax, к приложениям использующим
веб-сокеты. Regenix позволяет разрабатывать такие сложные приложения не задумываясь, что
скрыто за этими технологиями, разработчик пишет одинаковый код и для ajax-а и для остального.

#### HTTP и вызов скриптов

В PHP представления и контроллеры смешены между собой, а правила url строятся по
файловой структуре проекта. Все фреймворки исправляют этот недостаток во всех смыслах.
Каждый фреймворк делает это по своему. Система связывания url с кодом называется
роутингом или ЧПУ. В Regenix используются файлы конфигураций для роутинга, которые очень
просты для чтения.

Пример конфигурации из Regenix для роутинга:

    GET    /cliens/{id}/       Clients.show()

Понятно что по запросу GET адреса `/clients/32/` будет вызван метод show класса Clients и ему
будет передан аргумент `id = 32`. В тоже время контроллеру будет передана вся нужная
и дополнительная информация - Request, Response, Session, Headers и т.д.

#### Контролеры, простые и удобные

На каждый запрос Regenix пытается создать экземпляр контроллера исходя из правил роутинга
и вызвать нужный метод. При этому разработчику доступно большое количество вспомогательной
информации, помошников для управления HTTP циклом приложения. Посмотрим пример контроллера:

    namespace controllers;

    use framework\mvc\Controller;

    class Clients extends Controller {

        public function show($id){
            // show client with $id
            $this->put("client", /* findById($id) */);
            $this->render(); // render Clients/show.html
        }
    }

Из контроллера разработчик может получать и манипулировать информацией из таких классов и
помошников: *Request* - приходящий запрос, *Response* - ответ браузеру, *Headers* - пришедшие
заголовки, *Session* - упраление ссесией, *Flash* - управление живущими один запрос flash сообщениями,
*Query* - массив GET параметров запросов и другая информация.

Разработчик может писать хуки для контроллеров - *onBefore*, *onAfter*, *onFinally*, управляя таким образом
жизненным циклом контроллера. Он также может переопределить вывод Exception, если он возник
в каком-то методе контроллера. При этом всем поддерживается наследование.

#### Эффективный движок шаблонов

В мире PHP существует несколько подходов для создания шаблонов - использовать PHP как
шаблонизатор или использовать стороний шаблонизатор. Первый вариант является не очень
удобным, но очень производительным, второй вариант - удобен, но страдает производительность.
В PHP существует известные шаблонные движки Smarty и Twig, Regenix опционально поддерживает
эти движки, но у фреймворка есть свой движок, он очень производителен и является надстройкой
для php шаблонов, он упрощает синтаксис выражений.

Для примера шаблоны PHP и Regenix:

    Your name `<?php echo htmlspecialchars($var)?>`, <a href="<?php echo $linkLogout->render()?>">logout</a>.
    Now <?php date($time, 'd.m.Y')?>

и в regenix:

    Your name `${var}`, <a href="${linkLogout->render()}">logout</a>.
    Now ${time->format('d.m.Y')}

Синтаксис шаблонов в Regenix очень простой и понятный, по-умолчанию весь вывод переменных экранируется, но
всегда имеется возможность вывести неэкраннированную переменную. И всегда остается возможность использовать
другой движок - Smarty или Twig, или чистый PHP.

#### Система моделей, ORM и ODM

Regenix не реализует какую-то ORM, он только предоставляет интерфейсы для реализаций ORM, ActiveRecord и т.д.
На основе этих интерфейсов и классов очень легко строить дополнительные модули, которые
реализуют ORM архитектуру.

В Regenix логика работы с моделями отделена от самих моделей, она находится в сервисах (Services).
У каждой модели есть свой сервис для работы с ней, по-умолчанию он есть у всех и является стандартным.
Но можно переопределять и дописывать свои сервисы для каждой модели по отдельности.
Сервисы занимаются сохранением, удалением, добавлением и поиском моделей в базе данных, они также должны
выполнять более сложные операции. Модели же оперирует только со своими данными не зная о существовании
сервисов.

В фреймворке есть своя система аннотаций, которая использует комментарии php. На основе этих аннотаций
составляется описание моделей. Эта универсальная система аннотирования моделей заложена в ядро Regenix.
По-умолчанию в Regenix входит модуль ORM для работы с MySQL, SQLite, Postgres и ODM модуль для работы
с MongoDB.

Пример работы с моделями и сервисами:

Описание модели:

    /**
     * @collection posts
     */
    class Post extends Document {

        const type = __CLASS__;

        /**
         * @id
         * @var \MongoId
         */
        public $_id;

        /**
         * @length 255
         * @var string
         */
        public $name;

        /**
         * @length 10000
         * @var string
         */
        public $desc;

        /**
         * @indexed
         * @var string
         */
        public $author;

        /**
         * @var int
         */
        public $skip;

        /**
         * @var int[]
         */
        public $groups = array();
    }

Работа с моделью:

    $postService = Post::getService();

    $post = new Post();
    $post->name = 'Article name';
    $post->autor = 'Mike';
    $post->dateCreated = time();

    // save or insert if not exists
    $postService->save($post);
    // $post->getId() - return saved id


#### Поиск ошибок на этапе разработки

Язык PHP не является типо-безопастным, он не статически-типизирован, и предоставляет
слишком много свободы. Это грозит плохими последствиями. Regenix
частично исправляет эти недостатки, заставляя разработчика обращать на многие
ошибки в его коде, не пытается проигнорировать ошибки и как-то самостоятельно
исправлять их.

Вывод ошибок в Regenix очень удобен, он отображает где произошла ошибка, отображает
часть кода в котором произошла ошибка прямо в браузере. Это позволяет сразу определять
причину ошибки.

#### Контроль над типами данных

В php слабый контроль над типами данных. Поэтому Regenix реализует во многих местах
контроль или автоматическую конвертацию типов самостоятельно, это позволяет
избежать многих ошибок еще на этапе разработки.

Очень важно контролировать и конвертировать в нужные типы данных приходящие данные
от пользователей в POST, GET и т.д. Regenix предоставляет методы для конвертации
приходящих данных в нужные типы и объекты (binginds). Он также предоставляет
контроль типов на уровне роутинга.

Для примера в роутинге:

    GET /cliens/{id:int}/           Clients.show()
    POST /switch/{check:bool}       Switch.check()

В данных случаях параметры `id` и `check` в контроллер поступают уже в указанных типах,
это избавляет разработчика от ручного конвертирования типов в методе контроллера. Здесь
также можно указать и классы, для которых реализован биндинг (binging).

Или попробуем реализовать класс с реализацией binding'a, для этого его нада унаследовать
от интерфейса `RequestBindValue` и реализовать метод `onBindValue`. На простом примере
реализуем класс `Integer` просто для примера:

    namespace types;
    use framework\mvc\RequestBindValue;

    class Integer implements RequestBindValue {
        public $value;

        public function onBindValue($value){
            $this->value = (int)$value;
        }

        public function __toString(){
            return (string)$this->value;
        }
    }

В роутинге и не только можно теперь использовать класс Integer, чтобы конвертировать
приходящие данные в нужный формат. При этом экземпляр класса `Integer` будет создан
автоматически.

    GET /cliens/{id:types.Integer}/     Clients.show()

Для разделения namespace в роутинге используется `.` вместо `\`.