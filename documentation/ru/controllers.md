**Оглавление**

- [Введение](#intro)
- [Извлечение HTTP параметров](#httpargs)
- [Типизация параметров и HTTP данные](#typed)
- [Типы ответов](#resulttypes)

---

### Контроллеры

Контроллер обеспечивает связь между пользователем и системой. Они представляют
небольшую прослойку между моделями и представлениями, помогают отделить модели от
представлений в рамках MVC. Контроллеры не должны содержать в себе логику для работы
с моделями, и должны выполнять лишь роль "клея". Функционал для работы с моделью
обычно описывается в классе сервисе или в самой модели.


#### Введение <a name="intro"></a>

Контроллер это обычный PHP класс унаследованный от класса `framework\mvc\Controller`.

Для примера:

    <?php
    namespace controllers;

    use framework\mvc\Controller;

    class Clients extends Controller {

        public function show($id){
            $client = Client::getService()->findById($id);
            $this->put('client', $client);
            $this->render();
        }

        public function delete($id){
            $service = Client::getService();
            $client  = $service->findById($id);
            $service->delete($client);
            $this->render();
        }
    }

Каждый публичный не-статичный метод класса контроллера может быть действием. Общая схема
объявления такого метода:

    public function action_name($params...);

Вы можете добавить аргументов методу контроллера. Все указанные аргументы будут автоматически
связаны по названиям со значениями из $_GET параметров и аргументоми [роутинга](routes.md).
Аргументы роутинга имеют приоритет над аргументами из GET параметров.

Заметьте, что методы контроллера ничего не возвращают, не имеют `return` конструкции.
При вызове методы `render()` и ему подобных происходит выход из метода, как в случае
с return конструкцией. По этой причине использовать `return` нет смысла. А сам метод
`render()` вывод шаблон, есть и другие методы для вывода JSON, XML, Text и т.д.


#### Извлечение HTTP параметров <a name="httpargs"></a>

Каждый HTTP запрос передает набор данных - параметров. Эти данные могут быть извлечены из:

- Путь URI: `/clients/1234/`, 1234 это динамический параметр правила роутинга.
- Строка запроса: `/clients?id=1234`, id = 1234 аргумент и ему подобные.
- Тело запроса, POST и ему подобные данные.
- Переданные файлы из массива $_FILES (в стандарте PHP).

Regenix не имеет метода возвращающего все параметры сразу, по примеру того же `$_REQUEST`.
Кстати, очень жестко не рекомендуется использовать `$_GET`, `$_POST`, `$_REQUEST` и т.п. массивы.

**Получение GET параметров**

Для получения данных параметров вы можете использовать аргументы метода, как было описано выше
или же использовать поле контроллера `query`, для примера:

    public function show(){
        $id = $this->query->getInteger('id');
    }

При этом вам доступны методы, которые приводят аргументы к нужному типу: `getString`, `getInteger`,
`getBoolean`, `getArray` и т.д. Вы также можете указать параметры по-умолчанию или проверить
существование параметра вообще с помощью метода `has()`.

    public function show(){
        if ($this->query->has('showAll')){
            ...
        }
    }


**Связывание (binding) HTTP параметров**

В Regenix существует и более продвинутый механизм связывания HTTP данных. Вы можете создать
специальный класс приходящих данных, его нужно унаследовать от класса `framework\mvc\RequestBindParams`
и объявить необходимые публичные поля. По названиям этих полей и будет происходить связывание
данных:

    class MyForm extends RequestBindParams {

        const method = 'POST';
        const prefix = 'form_';

        public $id;
        public $showAll;
    }


Вы можете указать источник данных в константе `method` (POST, GET, FILES, COOKIES). А также
можно указать префикс для имен параметров.

В данном случае форма будет принимать из POST данных аргументы `form_id`, `form_showAll` и записывать
их значения в поля `$id` и `$showAll`.

Чтобы использовать эту форму в контроллере добавьте аргумент с любым названием в методе контроллера:

    public function save(MyForm $form){
        $this->renderDump($form);
    }

Заметьте, что в методе указан тип аргумента, его необходимо указывать, чтобы Regenix мог понять
какого класса ему нужно создать экземпляр.

> Для классов унаследованных от `framework\mvc\RequestBindParams` в аргументах метода контроллера
> игнорируется связывание с данными из GET и роутинга, что вполне логично.


Вы можете получить экземпляр формы и без указания аргументов в методе контроллера, делается это
с помощью статичного метода класса формы `::current()`

    public function save(){
        $form = MyForm::current();
        $this->renderDump($form);
    }

> Метод current работает из любого места в коде, не только в методах контроллера.


#### Типизация параметров и HTTP данные <a name="typed"></a>

Приходящие данные из HTTP параметров часто нужно приводить к нужному типу или классу.
Это довольно утомительно, поэтому regenix предоставлять механизмы конвертирования
типов через файл роутинга или через указание классов аргументов метода контроллера.

В роутинге делается это просто, таким образом:

    GET     /clients/{id:int}/      Clients.show

В данном случае `id` будет приведен к типу integer, это соответствует выражению `(integer)$id`.
Здесь в качестве типа можно указать и класс, наобходимо указывать полное название класса указывая
его namespace:

    GET     /clients/{id:types.Integer}/    Clients.show

Здесь мы использовали класс `types\Integer`, заметьте что вместо `\` используется `.` для разделения
namespace'ов в правилах роутинга. Но прежде чем использовать класс `type\Integer`, необходимо
реализовать для него интерфейс `framework\mvc\RequestBindValue` и метод `onBindValue($value)`.

    namespace types;

    use framework\mvc\RequestBindValue;

    class Integer implements RequestBindValue {

        public $value;

        public function onBindValue($value){
            $this->value = (int)$value;
        }
    }

Regenix создает экземпляр `types.Integer` и передает значение аргумента в метод `onBindValue`.
Далее вы можете реализовать любую логику работы с данными.

Кроме того, не обязательно указывать название класса в файле роутинга, его можно указать средствами
PHP в самом методе класса контроллера:

    use types\Integer;
    ...

    public function save(Integer $id){
            $this->renderText($id->value);
    }



#### Типы ответов <a name="resulttypes"></a>

Все методы контроллеров генерируют HTTP ответы. Ответ HTTP это экземпляр класса `Response`,
все контроллеры уже содержать по-умолчанию экземпляр этого класса в поле `response`, поэтому
создавать объект этого класса чтобы отдать http ответ не обязательно.

Regenix использует механизм `Exception` для отдачи ответов, поэтому `return` использовать не
нужно. У каждого контроллера есть набор готовых методов для отдачи разных ответов,
большенство из них начинается с префикса `render`.

Для примера:

    public function show($id){
        $client = Client::getService()->findById($id);
        $this->put('client', $client);
        $this->render();
        echo 'это сообщение не будет выведено';
    }

В данном примере метод `render()` формирует Response объект ответа и выходит из метода с помощью
специального `Exception`.


**Вывод простого текста**

Для вывода обычного `text/plain` текста, используйте метод `renderText()`.

    public function ok(){
        $this->renderText('OK');
    }

**Вывод JSON данных**

Для вывода JSON строки есть специальный метод `renderJSON($data)`, он использует
стандартный механизм php для кодирования json `json_encode`. К тому же он также
обрабатывает ошибки json кодирования, позволяя их логировать или просто выводить.


**Вывод шаблонов**

Для вывода шаблонов используйте метод `render()` или метод `renderTemplate()`, они
позволяют выводить шаблоны, название которых формируется автоматически из названия
класса и метода контроллера, либо название шаблона можно задать вручную. В них
вы дополнительно можете передать массив именнованных аргументов вторым параметром.

    public function show(){
        $client = ...
        $this->renderTemplate('Clients/show.html', array('client' => $client));
    }

Или:

    public function show(){
        $client = ...
        $this->put('client', $client);
        $this->render();
    }

С помощью методов `put` и `putAll` вы можете передать аргумент или массив аргументов
в шаблон, не указывая их в самом методе `render()`.


**Вывод других данных**

Кроме того вам доступны следующие методы для вывода различных данных:

- `renderHTML()`: вывод HTML текста `text/html`.
- `renderFile()`: вывод файла, может выводить большие файлы без ущерба для нагрузки.
- `renderXML()`: не реализовано еще, TODO
- `renderDump()`: выводит переменную через функцию `print_r`.
- `todo()`: выводит шаблон с сообщением TODO.
- `ok()`: вывод пустую страницу со статусом 200.

